# 3379. Transformed Array

## Question
You are given an integer array `nums` that represents a circular array. Your task is to create a new array `result` of the **same** size, following these rules:

For each index `i` (where `0 <= i < nums.length`), perform the following **independent** actions:

- If `nums[i] > 0`: Start at index `i` and move `nums[i]` steps to the **right** in the circular array. Set `result[i]` to the value of the index where you land.
- If `nums[i] < 0`: Start at index `i` and move `abs(nums[i])` steps to the **left** in the circular array. Set `result[i]` to the value of the index where you land.
- If `nums[i] == 0`: Set `result[i]` to `nums[i]`.

Return the new array `result`.

> Note: Since `nums` is circular, moving past the last element wraps around to the beginning, and moving before the first element wraps back to the end.

### Example 1:
```
Input: nums = [3,-2,1,1]
Output: [1,1,1,3]
```

#### Explanation:
- For `nums[0]` that is equal to 3, If we move 3 steps to right, we reach `nums[3]`. So `result[0]` should be 1.
- For `nums[1]` that is equal to -2, If we move 2 steps to left, we reach `nums[3]`. So `result[1]` should be 1.
- For `nums[2]` that is equal to 1, If we move 1 step to right, we reach `nums[3]`. So `result[2]` should be 1.
- For `nums[3]` that is equal to 1, If we move 1 step to right, we reach `nums[0]`. So `result[3]` should be 3.

### Example 2:
```
Input: nums = [-1,4,-1]
Output: [-1,-1,4]
```

#### Explanation:
- For `nums[0]` that is equal to -1, If we move 1 step to left, we reach `nums[2]`. So `result[0]` should be -1.
- For `nums[1]` that is equal to 4, If we move 4 steps to right, we reach `nums[2]`. So `result[1]` should be -1.
- For `nums[2]` that is equal to -1, If we move 1 step to left, we reach `nums[1]`. So `result[2]` should be 4.

### Constraints
- `1 <= nums.length <= 100`
- `100 <= nums[i] <= 100`


## Solution
```typescript
function constructTransformedArray(nums: number[]): number[] {
    if (nums.length === 1) {
        return nums;
    }

    const result: number[] = Array(nums.length)

    const len = nums.length;
    for (let i = 0; i < len; i++) {
        if (nums[i] === 0) {
            result[i] = nums[i];
        } else if (nums[i] > 0) {
            let updateIndex = nums[i] + i;
            if (updateIndex < len) {
                result[i] = nums[updateIndex];
            } else {
                result[i] = nums[(updateIndex % len)];
            }
        } else {
            let updateIndex = Math.abs(nums[i]) % len;
            if (i - updateIndex >= 0) {
                result[i] = nums[i - updateIndex];
            } else {
                result[i] = nums[len - updateIndex + i];
            }

        }
    }

    return result;
};
```

## Mindset
1. If there is only **one** element in the array, return the original array because there is nothing to transform.
2. Iterate from 0 (the first index) to the last index of the array.
3. Inside the iteration, handle three cases:
    - `nums[i] === 0`
        - Keep the element at the same index.
    - `nums[i] > 0`
        - Starting from index `i`, move `nums[i]` steps to the right.
        - The final index after moving is `updateIndex = i + nums[i]`.
        - If the movement does **not** wrap around (`updateIndex < len`), set `result[i] = nums[updateIndex]`.
        - If the movement wraps around, take `updateIndex % len` to get the final index.
        - Example: Let `nums = [-1, 7, 4]` and `i = 1`. Then `updateIndex = 1 + 7 = 8`.
            - Moving 7 steps to the right from index 1 goes: 2 → 0 → 1 → 2 →0 → 1 → 2
            - Number of wraps required = `7 / 3 = 2`, remainder = 1 (i.e. 1 step remaining)
            - The movement is start from index 1, so add the remainder by 1 `(1 + 1 = 2)`
            - Finally, we know that the index after movement is 2 i.e. `result[1] = nums[2] = 4`.
            - To simplify the calculation, add the start index to number of steps required
                - `(7 + 1) % 3 = 7 % 3 + 1 = 2`
    - `nums[i] < 0`
        - Starting from index `i`, move `abs(nums[i])` steps to the left.
        - Let `updateIndex = abs(nums[i]) % len` be the number of steps to move after wrapping
        - If the movement does **not** wrap around (that is, `i - updateIndex >= 0`), set `result[i] = nums[i - updateIndex]`.
        - Otherwise, the movement wraps around to the end, and the final index is `len - updateIndex + i`.
        - Example: Let `nums = [-7, 4, 9]` and `i = 0`. Then `updateIndex = 7 mod 3 = 1`.
            - Since `0 - 1 = -1 < 0`, wrapping is required.
            - The final index is `3 - 1 + 0 = 2`, so `result[0] = nums[2] = 9`.