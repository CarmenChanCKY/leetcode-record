# 3637. Trionic Array I

## Question
You are given an integer array `nums` of length `n`.

An array is **trionic** if there exist indices `0 < p < q < n − 1` such that:

- `nums[0...p]` is **strictly** increasing,
- `nums[p...q]` is **strictly** decreasing,
- `nums[q...n − 1]` is **strictly** increasing.

Return `true` if `nums` is trionic, otherwise return `false`.

### Example 1:
```
Input: nums = [1,3,5,4,2,6]
Output: true
```

#### Explanation:
Pick `p = 2`, `q = 4`:

- `nums[0...2] = [1, 3, 5]` is strictly increasing (`1 < 3 < 5`).
- `nums[2...4] = [5, 4, 2]` is strictly decreasing (`5 > 4 > 2`).
- `nums[4...5] = [2, 6]` is strictly increasing (`2 < 6`).


### Example 2:
```
Input: nums = [2,1,3]
Output: false
```

#### Explanation:
There is no way to pick `p` and `q` to form the required three segments.

### Constraints
- `3 <= n <= 100`
- `1000 <= nums[i] <= 1000`

## Solution
```typescript
function isTrionic(nums: number[]): boolean {
    if (nums.length === 3) {
        return false;
    }
    let p = -1;
    let q = -1;

    let len = nums.length - 1;
    for (let i = 0; i < len; i++) {
        if (nums[i] < nums[i + 1]) {
            p = i
        } else if (nums[i] > nums[i + 1]) {
            break;
        } else {
            return false;
        }
    }

    if (p === -1) {
        return false;
    }

    p++;

    for (let i = p; i < len; i++) {
        if (nums[i] < nums[i + 1]) {
            break;
        } else if (nums[i] > nums[i + 1]) {
            q = i
        } else {
            return false;
        }
    }

    if (q === -1) {
        return false;
    }

    q++;

    if (q >= len) {
        return false;
    }

    for (let i = q; i < len; i++) {
        if (nums[i] >= nums[i + 1]) {
            return false
        }
    }

    return true;
};
```

## Mindset
1. According to Example 2, an input array with length 3 must return false. The program returns false directly if `nums.length = 3`.
2. Variable `p` checks whether the array is strictly increasing. It stores the last index where `nums[i] < nums[i + 1]` and stops when `nums[i] > nums[i + 1]` (no longer strictly increasing).
3. If `p === -1`, the array never increases, so the program returns false directly.
4. `p++` makes `p` the first index of the decreasing segment.
5. Variable `q` checks whether the array is strictly decreasing. Similar to `p`, it stores the last index where `nums[i] > nums[i + 1]`. The check starts from `p`.
6. If `q === -1`, the array never decreases, so the program returns false directly.
7. Since the question requires `0 < p < q < n − 1`, the program returns false directly if `nums[i] === nums[i + 1]`.
8. `q++` makes `q` the first index of the second increasing segment.
9. From `q` to the end of the array, if there are any decreasing item / same item (`nums[i] >= nums[i + 1]`), the program returns false directly.
10. Finally, the program returns true to indicate the input array fulfills the requirements.